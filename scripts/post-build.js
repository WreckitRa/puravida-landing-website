#!/usr/bin/env node

/**
 * Post-build script for Next.js static export
 * Ensures fallback.html exists for dynamic event routes
 */

const fs = require('fs');
const path = require('path');

const OUT_DIR = path.join(process.cwd(), 'out');
const EVENT_DIR = path.join(OUT_DIR, 'event');
const FALLBACK_FILE = path.join(EVENT_DIR, 'fallback.html');

console.log('üîß Running post-build script...');

// Ensure out directory exists
if (!fs.existsSync(OUT_DIR)) {
  console.error('‚ùå Error: out/ directory not found. Run "npm run build" first.');
  process.exit(1);
}

// Ensure event directory exists
if (!fs.existsSync(EVENT_DIR)) {
  console.log('üìÅ Creating event directory...');
  fs.mkdirSync(EVENT_DIR, { recursive: true });
}

// Check if fallback.html exists
if (!fs.existsSync(FALLBACK_FILE)) {
  console.log('‚ö†Ô∏è  Warning: event/fallback.html not found.');
  console.log('   This should be generated by Next.js from generateStaticParams.');
  console.log('   Checking for alternative event pages...');
  
  // Try to find any event page to use as template
  const eventFiles = fs.readdirSync(EVENT_DIR).filter(file => file.endsWith('.html'));
  
  if (eventFiles.length > 0) {
    const templateFile = path.join(EVENT_DIR, eventFiles[0]);
    console.log(`üìã Using ${eventFiles[0]} as template for fallback.html...`);
    const templateContent = fs.readFileSync(templateFile, 'utf8');
    fs.writeFileSync(FALLBACK_FILE, templateContent);
    console.log('‚úÖ Created fallback.html from template');
  } else {
    console.error('‚ùå Error: No event pages found to use as template.');
    process.exit(1);
  }
} else {
  console.log('‚úÖ fallback.html exists');
  
  // Verify the file has content
  const content = fs.readFileSync(FALLBACK_FILE, 'utf8');
  if (content.length < 100) {
    console.warn('‚ö†Ô∏è  Warning: fallback.html seems too small. It may be incomplete.');
  } else {
    console.log('‚úÖ fallback.html has valid content');
  }
}

// Verify .htaccess exists and has the correct rewrite rule
const htaccessFile = path.join(OUT_DIR, '.htaccess');
if (fs.existsSync(htaccessFile)) {
  const htaccessContent = fs.readFileSync(htaccessFile, 'utf8');
  if (htaccessContent.includes('event/([^/]+)')) {
    console.log('‚úÖ .htaccess has event route rewrite rule');
  } else {
    console.warn('‚ö†Ô∏è  Warning: .htaccess may be missing event route rewrite rule');
    console.log('   Updating .htaccess from public/.htaccess...');
    
    // Read public/.htaccess as source of truth
    const publicHtaccess = path.join(process.cwd(), 'public', '.htaccess');
    if (fs.existsSync(publicHtaccess)) {
      fs.copyFileSync(publicHtaccess, htaccessFile);
      console.log('‚úÖ Updated .htaccess from public/.htaccess');
    }
  }
} else {
  console.warn('‚ö†Ô∏è  Warning: .htaccess not found in out/ directory');
  console.log('   Copying from public/.htaccess...');
  
  // Copy from public if it exists
  const publicHtaccess = path.join(process.cwd(), 'public', '.htaccess');
  if (fs.existsSync(publicHtaccess)) {
    fs.copyFileSync(publicHtaccess, htaccessFile);
    console.log('‚úÖ Copied .htaccess to out/ directory');
  } else {
    console.error('‚ùå Error: public/.htaccess not found');
  }
}

console.log('‚úÖ Post-build script completed successfully');

